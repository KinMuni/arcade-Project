
/**
 *@class{Enemy} with Variables:
 *  x- X_axis, 
 *  y-Y-axis positions of the enemy
 * speed: Speed
 * */
// Enemy class
const Enemy = function(x, y, speed) {
    // Variables applied to each of our instances 
    this.x = x;
    this.y = y;
    this.speed = speed;
    // The image/sprite for our enemies, 
    this.sprite = 'images/enemy-bug.png';
};
/** 
* Method to update the enemy's position
* Parameter: dt, a time delta between ticks
* Multiply the speed by dt on x-axis to ensure game runs at the same speed for all computers.
* */
Enemy.prototype.update = function(dt) {
    // multiply by dt parameter
     this.x += this.speed * dt;
      //Enemies randomnly reappear with different speeds  after they  go off canvas 
     if(this.x > 550) {
         this.x = -65;
         this.speed = 150 * (Math.random() *4);
         
     };
     // check collisions between the player and the enemies
     //when collision occur the play return to the starting point{202, 405}
     if (player.x < this.x + 60 &&
        player.x +60 > this.x &&
        player.y < this.y + 50 &&
        50 + player.y > this.y) {
        player.x = 202;
        player.y = 405;
    };
};
/** 
* Method to render the enemy on the screen
* Draw the enemy on the screen, required method for game
* */
// Draw the enemy on the screen, required method for game
Enemy.prototype.render = function () {
    ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
};

/**
 *@class{Player} with Variables:
 *  x- X_axis, 
 *  y-Y-axis positions of the enemy
 * */
// Player class
const Player = function (x, y) {
    // variables
    this.x = x;
    this.y = y;
    // the princess-gril image loaded to the player
    this.player = 'images/char-princess-girl.png';
};

// This class requires an update() method,
Player.prototype.update = function (dt) {

};
/** 
* Method to render the player on the screen
* Draw the player on the screen, required method for game
* */
//render the image of the player
Player.prototype.render = function() {
    ctx.drawImage(Resources.get(this.player), this.x, this.y);
};
/** 
* Method to handle inputs
* Draw the player on the screen, required method for game
* Allows the user to use the arrow keys to jump from tile to tile
* */
// a handleInput() method.
Player.prototype.handleInput = function (keyPress) {

    //Permit the user on left arrow key to move left  and
    // not go off the games tiles on the left side
    
    if (keyPress == 'left' && this.x > 0) {
        this.x -= 102;
    };
    //Permit the user using right arrow key to move right and
    // not go off the games tiles on the rightside

    if (keyPress == 'right' && this.x < 405) {
        this.x += 102;
    };

    // Permit user on up arrow key to move upwards and 
    //not go off the game tiles on top side
    if (keyPress == 'up' && this.y > 0) {
        this.y -= 83;
    };
    // Permit user on up arrow key to move downwards and 
    //not go off the game tiles on bottom side
    
    if (keyPress == 'down' && this.y < 405) {
        this.y += 83;
    };

    // Once the user reaches the the water, the user is
    // Instantly reset to the starting position
    if (this.y < 0) {
        setTimeout(() => {
            this.x = 202;
            this.y = 405;
        }, 500);
   };
};


// All enemies are placed in an array
const allEnemies = [];

//  3 enemies are lacated on the y axis located on the stone road
// Move at speed of 250 until the got generated by the method 
const enemy_position = [68, 145, 220];

enemy_position.forEach(function (position_Y) {
    enemy = new Enemy(0, position_Y, 350);
    allEnemies.push(enemy);
});

// The starting location of the player is located at x = 202, y=405
const player = new Player(202, 405);

// This listens for key presses and sends the keys to your
// Player.handleInput() method. You don't need to modify this.
document.addEventListener('keyup', function(e) {
    const allowedKeys = {
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down'
    };

    player.handleInput(allowedKeys[e.keyCode]);
});
